<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Xcode8,Xcode9 查看模拟器沙盒目录的方法]]></title>
      <url>/2017/12/05/12/</url>
      <content type="html"><![CDATA[<p>自从升级到Xcode8之后，所有的插件都被禁用了，那么应该如何进入模拟器的沙盒目录呢？<br><a id="more"></a><br>自从升级到Xcode8之后，所有的插件都被禁用了，那么应该如何进入模拟器的沙盒目录呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSLog(@&quot;%@&quot;, paths[0]);</span><br></pre></td></tr></table></figure></p>
<p>打开Finder，点前往<br>把打印出来的path复制到输入框中按回车即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo中的Yelee主题，首页不显示文章摘要]]></title>
      <url>/2017/12/04/2/</url>
      <content type="html"><![CDATA[<p>最近在用Hexo自己搭建博客，使用了文档比较全的Yelee主题，但是在使用过程中发现了一个大问题，在所有文章列表中有文章，但是首页却不显示文章摘要。<br><a id="more"></a><br>最近在用Hexo自己搭建博客，使用了文档比较全的Yelee主题，但是在使用过程中发现了一个大问题，在所有文章列表中有文章，但是首页却不显示文章摘要。</p>
<p>我找了一下，发现是themes/yelee/layout/_partial/head.ejs中的这段代码的search: &lt;%= theme.search.on %&gt;定义有问题。</p>
<p>具体代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var yiliaConfig = &#123;</span><br><span class="line">    fancybox: &lt;%=theme.fancybox%&gt;,</span><br><span class="line">    animate: &lt;%=theme.animate%&gt;,</span><br><span class="line">    isHome: &lt;%=is_home()%&gt;,</span><br><span class="line">    isPost: &lt;%=is_post()%&gt;,</span><br><span class="line">    isArchive: &lt;%=is_archive()%&gt;,</span><br><span class="line">    isTag: &lt;%=is_tag()%&gt;,</span><br><span class="line">    isCategory: &lt;%=is_category()%&gt;,</span><br><span class="line">    fancybox_js: <span class="string">"&lt;%- theme.CDN.fancybox_js %&gt;"</span>,</span><br><span class="line">    scrollreveal: <span class="string">"&lt;%- theme.CDN.scrollreveal %&gt;"</span>,</span><br><span class="line">    search: &lt;%= theme.search.on %&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看这里最后一个search，里面用的是on，而在yelee主题的_config.xml里默认设置是search:onload:false，这里写的是onload而不是on，导致Uncaught ReferenceError: yiliaConfig is not defined。</p>
<p>解决方法是把两边的变量名改成一样就可以了，比如yelee主题的_config.xml里面的search:onload false改成search:on false，这样就正常运行了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 设置Launchpad 的列数和行数]]></title>
      <url>/2017/11/13/3/</url>
      <content type="html"><![CDATA[<p>这两天在搞博客的事情，发现Mac的Launchpad里面一页显示的东西太少，很不方便，于是就搜集了一下如何让她显示更多图标的方法。<br><a id="more"></a></p>
<p>打开终端。</p>
<ol>
<li><p>设置 Launchpad 的列数，对应于每一行 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-columns -int 列数</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 Launchpad 的行数，对应于每一列 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows -int 行数</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Launchpad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Dock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[加密和签名的区别]]></title>
      <url>/2017/11/08/4/</url>
      <content type="html"><![CDATA[<p>最近在研究RSA，对其中的签名和加密的概念不是很理解，从网上搜了搜，在这里总结一下。<br><a id="more"></a><br>最近在研究RSA，对其中的签名和加密的概念不是很理解，从网上搜了搜，在这里总结一下。</p>
<p>举个例子，就拿A给B发送经过签名加密信息来说：<br>1、A对信息签名的作用是确认这个信息是A发出的，不是别人发出的；<br>2、加密是对内容进行机密性保护，主要是保证信息内容不会被其他人获取，只有B可以获取。也就是保证整个过程的端到端的唯一确定性，这个信息是A发出的（不是别人），且是发给B的，只有B才被获得具体内容（别人就算截获信息也不能获得具体内容）。</p>
<p>这只是大概说了作用，具体说来，涉及到密钥相关的东西。密钥有公钥和私钥之分。</p>
<p>那么这里一共有两组四个密钥：<br>A的公钥（PUB_A），A的私钥（PRI_A）；B的公钥（PUB_B），B的私钥（PRI_B）。</p>
<p>公钥一般用来加密，私钥用来签名。</p>
<p>通常公钥是公开出去的，但是私钥只能自己私密持有。<br>公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；同样用某个私钥加密的内容只能用对应的公钥才能解密。</p>
<p>这时A向B发送信息的整个签名和加密的过程如下：<br>1、A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。<br>2、A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。</p>
<p>这样当B接收到A的信息后，获取信息内容的步骤如下：<br>1、B用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容；<br>2、得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。</p>
<p>从而整个过程就保证了开始说的端到端的唯一确认。<br>A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的。<br>A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。</p>
<p>这个过程可以这么个故事来概括:<br>B的银行卡落到A的家里了，A要给B邮寄银行卡，提前和B说了我要给你寄银行卡(B拿到A的公钥)，<br>A在寄银行卡的时候要求快递员在B收到东西时说出是谁寄的(A用自己的私钥进行签名)，只有说对了才给B(B用A的公钥验证签名)。</p>
<p>这张银行卡对于快递员来说是加密的(快递员既不知道银行卡是谁的，也不知道银行卡密码)，但是对于A来说，A知道银行卡是谁的(相当于B的公钥)，而对于B来说，B有银行卡的密码(B的私钥)。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你真的了解位运算？用了这个运算符，算法的时间复杂度竟然降了一个数量级！]]></title>
      <url>/2017/04/06/14/</url>
      <content type="html"><![CDATA[<p>其实这个运算符很容易被人忽略，他就是C语言中的位异或运算符^<br>位运算符家族中，最常用的，莫过于异或运算符。<br><a id="more"></a><br>其实这个运算符很容易被人忽略，他就是C语言中的位异或运算符^<br>位运算符家族中，最常用的，莫过于异或运算符。</p>
<p>我们先看异或运算符的定义： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。<br>即：0^0=0， 1^0=1， 0^1=1， 1^1=0</p>
<p>例如：10100001^00010001=10110000<br>0^0=0,0^1=1    可理解为： 0异或任何数，其结果=任何数<br>1^0=1,1^1=0    可理解为： 1异或任何数，其结果=任何数取反<br>任何数异或自己，等于把自己置0</p>
<p>通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现：<br>a=10100001,   b=00000110<br>a=a^b； 　　//a=10100111<br>b=b^a； 　　//b=10100001<br>a=a^b； 　　//a=00000110</p>
<p>异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</p>
<p>利用他的特点，我们可以解决一个常见的问题：<br>Single Number: 整数型数组中，每个元素均出现两次，除了一个元素例外，如何找出这个元素？能否设计一个线性时间的算法，且不需要额外的存储空间？</p>
<p>其实O(n)的算法不容易一下子想到，先说说常规的解决思路，有如下两种：<br>1、对元素的出现次数进行统计，可进行n*n循环，判断元素是否只出现了一次。这样时间复杂度为O(n^2), 不需要额外空间。<br>2、先对元素进行排序，然后进行相邻两元素的对比，如a1和a2对比，a3和a4对比，如果不同，则前一个元素(a1、a3)就是所要查找的元素。<br>这两种解法的时间复杂度都比O(n)更高。但是，如果你运用了异或运算符的特点，那么这个问题就很容易解决了，算法复杂度为O(n)，且不需要额外空间，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(int A[], int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result ^=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于数据结构和内存中堆和栈，你可能还不知道的几个区别]]></title>
      <url>/2017/03/16/15/</url>
      <content type="html"><![CDATA[<p>堆和栈是数据结构中最常见的两种结构。<br><a id="more"></a></p>
<ol>
<li><p>数据结构中的堆和栈<br>堆和栈在数据结构中是两种不同的数据结构。 两者都是数据项按序排列的数据结构。<br>栈：像是装数据的桶或者箱子<br>栈是大家比较熟悉的一种数据结构，它是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放入比较晚的物体）。<br>堆：像是一颗倒立的大树<br>堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</li>
<li><p>内存分配中的堆和栈<br>我们现在经常用的并不是数据结构中的堆和栈，之所以说了数据结构中的堆和栈是为了和后面将要说的堆区和栈区区别开来，请大家一定要注意。<br>下面说一下C语言程序内存分配中的堆和栈，这里有必要把内存分配也提一下，大家不要嫌弃本姑娘萝莉啰嗦啦，一般情况下 程序存放在Rom或Flash中，运行事需要拷贝到内存中执行，内存会分别存储不同的信息。</p>
</li>
</ol>
<p>内存中的栈区处于相对较高的地址，以地址的增长方向为上的话，栈地址是向下增长的。<br>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的。只读区是分配常量和程序代码空间的；以及其他一些分区。</p>
<p>来看一个很经典的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;  全局初始化区</span><br><span class="line">char *p1;  全局未初始化区</span><br><span class="line">void main ()&#123;</span><br><span class="line">    int b; 栈</span><br><span class="line">    char  s[] = &quot;abc&quot;;栈</span><br><span class="line">    char *p2; 栈</span><br><span class="line">    char *p3 = &quot;123456&quot;; 123456\0 在常量区，p3 在栈区</span><br><span class="line">    static  int c = 0； 全局（静态）初始化区</span><br><span class="line">    p1 = (char *)malloc(10);堆</span><br><span class="line">    p2 = (char *)malloc (20);堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>内存分配中栈区和堆区的区别<br>0、申请方式和回收方式不同<br>不知道你是否有点明白了，堆和栈的第一个区别就是申请方式的不同：栈（英文名字;stack）是系统自动分配空间的<br>，例如我们定义了一个 char a ；系统会自动的在栈上为其开辟空间。而堆（英文名字:heap）则是程序员根据需要自己申请的空间，例如malloc(10); 开辟是个字节的空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。</li>
</ol>
<p>1、 申请后系统的响应<br>栈 ： 只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆。<br>结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题</p>
<p>2、申请效率的比较<br>栈：  由系统自动分配，速度较快。但程序员是无法控制的。<br>堆：  是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<p>3、 申请大小的限制<br>栈： 在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>4、堆和栈中的内存内容<br>由于栈的大小限制，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。<br>栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的吓一跳可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是有右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>5、 关于堆和栈一个比较形象的比喻<br>栈：使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、吃（使用），吃饱了就走，不必理会切菜，洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处就是快捷，但是自由度小。</p>
<p>堆：使用堆就像是自己动手做喜欢的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 一直弹出登录iCloud的解决方法]]></title>
      <url>/2017/01/05/11/</url>
      <content type="html"><![CDATA[<p>一直弹出的时候，你随便输入密码，输三次，它会出现让你重设密码，然后点击重设，会出现网页，然后直接按home键就可以 ，前提是必须要连上网。<br><a id="more"></a><br>一直弹出的时候，你随便输入密码，输三次，它会出现让你重设密码，然后点击重设，会出现网页，然后直接按home键就可以 ，前提是必须要连上网。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下如何查看Git的全局忽略列表]]></title>
      <url>/2016/11/22/6/</url>
      <content type="html"><![CDATA[<p>有时在使用Git的时候会发现有些文件明明在目录里，但是Git却没有自动添加到版本跟踪里面，查看仓库的忽略列表也没有，那么有很大可能是在Git的全局忽略列表里。<br><a id="more"></a><br>有时在使用Git的时候会发现有些文件明明在目录里，但是Git却没有自动添加到版本跟踪里面，查看仓库的忽略列表也没有，那么有很大可能是在Git的全局忽略列表里。</p>
<p>打开Finder(如果连这个都不知道的话，还是用回Windows吧)<br>在显示器的顶部菜单选择前往-&gt;前往文件夹<br>输入~/.gitignore_global</p>
<p>右键用记事本打开即可</p>
<p>如果不显示，请允许Mac显示所有隐藏文件！！<br>打开终端，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true       此命令显示隐藏文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool false      此命令关闭显示隐藏文件</span><br></pre></td></tr></table></figure></p>
<p>命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可<br>重启电脑也可以。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3 单例模式]]></title>
      <url>/2016/11/16/8/</url>
      <content type="html"><![CDATA[<p>单例模式是开发中很常用的一种设计模式，一般几十行甚至十几行代码就可以搞定，Swift里面有这么几种单例的写法，供大家参考。<br><a id="more"></a><br>常见的有这么几种方法</p>
<ol>
<li>第一种<br>最简单也是最常用的，这里的所有单例init方法一定要定义成private的，不然外部依然可以使用init方法初始化变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final class Single: NSObject &#123;</span><br><span class="line">    static let shared = Single()</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final关键字的作用是这个类或方法不希望被继承和重写</p>
<ol>
<li>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public extension DispatchQueue &#123;</span><br><span class="line">    private static var onceToken = [String]()</span><br><span class="line">    public class func once(_ token: String, _ block:@escaping () -&gt; Void) &#123;</span><br><span class="line">        objc_sync_enter(self)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(self)</span><br><span class="line">        &#125;</span><br><span class="line">        if onceToken.contains(token) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        onceToken.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Single2: NSObject &#123;</span><br><span class="line">    static func shared() -&gt; Single2 &#123;</span><br><span class="line">        struct Singleton &#123;</span><br><span class="line">            static var single = Single2()</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.once(&quot;YouShaoduo&quot;) &#123;</span><br><span class="line">            Singleton.single = shared()</span><br><span class="line">        &#125;</span><br><span class="line">        return Singleton.single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第二种完全是OC风格的单例，但是由于Swift3中废弃了原来的dispatch_once_t，所以需要先给DispatchQueue添加一个extension，实现原先的dispatch_once_t效果</p>
<ol>
<li><p>第三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private let single = Single3()</span><br><span class="line">final class Single3: NSObject &#123;</span><br><span class="line">    static var shared: Single3 &#123;</span><br><span class="line">        return single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileprivate override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final class Single4: NSObject &#123;</span><br><span class="line">    static var shared: Single4 &#123;</span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static let instance: Single4 = Single4()</span><br><span class="line">        &#125;</span><br><span class="line">        return Static.instance</span><br><span class="line">    &#125;</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法的实现原理是在方法内定义静态变量</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设置Git区分文件名大小写]]></title>
      <url>/2016/11/16/5/</url>
      <content type="html"><![CDATA[<p>git 默认不区分文件名大小写。<br><a id="more"></a><br>git 默认不区分文件名大小写。</p>
<p>当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.</p>
<p>然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.</p>
<p>控制台输入git status 也不显示任何信息</p>
<p>那么就配置git 使其对文件名大小写敏感，直接在终端中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree(Git)不识别新添加的文件]]></title>
      <url>/2016/11/16/10/</url>
      <content type="html"><![CDATA[<p>今天在做项目的时候新建了一个viewController，但是sourceTree只显示新增了.h文件，在网上找了许多方法发现没有用，比如那个删掉.git隐藏文件的，删掉就SB了。<br><a id="more"></a><br>今天在做项目的时候新建了一个viewController，但是sourceTree只显示新增了.h文件，在网上找了许多方法发现没有用，比如那个删掉.git隐藏文件的，删掉就SB了。<br>找了好久没找到，无奈只能自己试验了。</p>
<p>工作目录中，新建一个文件，比如一个.h和.m文件。</p>
<p>但是，git无法识别这些文件。</p>
<p>用git status命令，返回目录是clean的。表明没有任何修改。说明git没有识别到这些新增加的文件。也说明这个问题是git内部的问题，跟用什么版本控制工具没关系（不是sourcetree的锅）</p>
<p>首先，找到了原因，那么强制给他加一下，用终端到文件目录下，然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 1.m</span><br></pre></td></tr></table></figure></p>
<p>返回无法添加，说1.m已经处于.gitignore中。但是iganore中明明没有忽略这些m文件。</p>
<p>那就更狠一点，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f 1.m</span><br></pre></td></tr></table></figure></p>
<p>这样就可以将1.m添加到git的版本控制中。</p>
<p>如果直接git add -f 1.m</p>
<p>报错，无法找到文件1.m</p>
<p>那么就将1.m的完整路径输入即可。</p>
<p>建议先看一下全局忽略列表里有没有，查看Git全局忽略列表的方法在我的另一篇文章中有，请自行查阅。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 中的for循环，正序与逆序(倒序)]]></title>
      <url>/2016/11/02/9/</url>
      <content type="html"><![CDATA[<p>看了许多关于Swift  for循环的文章，发现基本上都是正序的for循环，对于逆序的我一直使用while循环，直到我发现了这个方法。。。<br><a id="more"></a><br>看了许多关于Swift  for循环的文章，发现基本上都是正序的for循环，对于逆序的我一直使用while循环，直到我发现了这个方法。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in (0...10).reversed() &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用这个就可以倒序for循环了</p>
<p>还有另一种比较优雅而且装X的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 3, through: 0, by: -1) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Swift 的 stride 函数返回一个任意可变步长 类型值的序列。可变步长类型是可以设置偏移量的一维标量。<br>他有两个变种，<br>from，to，最后一个值将会严格小(大)于to的值<br>stride(from:3, to:0, by:-1) 表示3，2，1</p>
<p>from，through，最后一个值将会小(大)于等于through的值<br>stride(from:3, through:0, by:-1) 表示3，2，1，0</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree超前一个版本，落后N个版本]]></title>
      <url>/2016/10/08/1/</url>
      <content type="html"><![CDATA[<p>在使用SourceTree的时候经常会遇见超前一个版本，落后N个版本的情况，遇见这种情况应该怎么办呢？</p>
<p>首先打开终端，最好是从SourceTree里面打开，菜单栏有个终端按钮。<br><a id="more"></a><br>在使用SourceTree的时候经常会遇见超前一个版本，落后N个版本的情况，遇见这种情况应该怎么办呢？</p>
<p>首先打开终端，最好是从SourceTree里面打开，菜单栏有个终端按钮。<br>然后输入(不要用这个，用下面的)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是将自己最近的一次提交撤销，回到push之前的状态。但是所有commit的内容就都消失了。非常不建议用这个参数，会牺牲太多的代码。。<br>如果不想让commit消失，可以改一下参数。用这个参数可以保证你提交的代码原封不动的保存下来。前提是你本地的工作台是干净的。如果不是请把所有代码都暂存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure></p>
<p>执行这句话之后重新拉取一遍代码就可以了，push的都会撤销回来。</p>
<p>如果想一次回退多个push，可以这样：(例子是撤销最近三次的提交)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~3</span><br></pre></td></tr></table></figure></p>
<p>如果想回退到某个指定版本，在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft 1234567</span><br></pre></td></tr></table></figure></p>
<p>1234567是要回退到的版本号，根据具体情况而定，这里只是举例子。<br>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>最后总结一下：</p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSProcessInfo类方法]]></title>
      <url>/2016/08/26/13/</url>
      <content type="html"><![CDATA[<p>NSProcessInfo类中的方法很有用。<br><a id="more"></a><br>let i =NSProcessInfo.processInfo()<br>print(i.systemUptime)          //返回系统的运行时长<br>print(i.processName)           //返回当前正在执行的进程名称<br>print(i.arguments)             //以NSString对象数组的形式返回当前进程的参数<br>print(i.environment)           //返回变量/值对词典，以描述当前的环境变量（比如PATH和HOME）及其值<br>print(i.processIdentifier)     //返回进程标识符，它是操作系统赋予进程的唯一数字，用于识别每个正在运行的进程<br>print(i.processorCount)        //返回线程数量<br>print(i.globallyUniqueString)  //每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名<br>print(i.hostName)              //返回主机系统的名称（在笔者的iOS系统中，返回的是iPhone）<br>print(i.operatingSystemVersion)//返回操作系统的版本<br>print(i.operatingSystemVersionString)//返回操作系统的版本以及build号</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS获取当前版本号 Bundle ID等信息的方法]]></title>
      <url>/2016/08/23/7/</url>
      <content type="html"><![CDATA[<p>很多地方都会用到获取当前App的版本号。<br><a id="more"></a><br>1：获取bundle Id信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] bundleIdentifier];</span><br></pre></td></tr></table></figure></p>
<p>2：获取版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br></pre></td></tr></table></figure></p>
<p>3：获取build号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleVersion&quot;];</span><br></pre></td></tr></table></figure></p>
<p>4：获取App显示名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleDisplayName&quot;];</span><br></pre></td></tr></table></figure></p>
<p>其实 [[NSBundle mainBundle]infoDictionary] 获得的是一个字典，里边放着Info.plist文件中的各种信息，根据不同的键去即可，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CFBundleDevelopmentRegion</span><br><span class="line"></span><br><span class="line">CFBundleDisplayName</span><br><span class="line"></span><br><span class="line">CFBundleExecutable</span><br><span class="line"></span><br><span class="line">CFBundleExecutablePath</span><br><span class="line"></span><br><span class="line">CFBundleIdentifier</span><br><span class="line"></span><br><span class="line">CFBundleInfoDictionaryVersion = &quot;6.0&quot;;</span><br><span class="line"></span><br><span class="line">CFBundleInfoPlistURL</span><br><span class="line"></span><br><span class="line">CFBundleName</span><br><span class="line"></span><br><span class="line">CFBundlePackageType</span><br><span class="line"></span><br><span class="line">CFBundleShortVersionString</span><br><span class="line"></span><br><span class="line">CFBundleSignature</span><br><span class="line"></span><br><span class="line">CFBundleSupportedPlatforms</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
